interval_width = 0.4,
num_cores = 12
)
})
embedded <- ColorEmbedding(Mapper, data_with_label, 'mnist_label', type='most_common')
embedded
MapperPlotter(Mapper, label=embedded, data=pca, type="forceNetwork", avg=FALSE, use_embedding=TRUE)
nrow(pca)
data
mnist_images
mnist_images$images
data_with_label
MapperPlotter(Mapper, label=data_with_label$mnist_label, data=pca, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
embedded <- ColorEmbedding(Mapper, data_with_label, 'mnist_label', type='mean')
source('R/ColorEmbedding.R')
ifelse(data$Petal.Width > 1.5, "wide", "narrow")
data("iris")
data <- iris
ifelse(data$Petal.Width > 1.5, "wide", "narrow")
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
data
embedded <- ColorEmbedding(Mapper, list("PW_group", "Species"), 'Petal.Length', type='mean', a_level = "wide", b_level = "setosa")
embedded <- ColorEmbedding(Mapper, list("PW_group", "Species"), 'Petal.Length', type='conditional_prob', a_level = "wide", b_level = "setosa")
ColorEmbedding <- function(
Mapper, original_data, columns=list(), type="mean",
a_level = NULL, b_level = NULL
) {
rows <- length(Mapper$level_of_vertex)
df_for_search <- data.frame()
target_lst <- list()
for (i in 1:rows) {
# Get original index
original_row_lst <- Mapper$points_in_vertex[[i]]
df_for_search <- rbind(
df_for_search,
data.frame(
node = i,
original_indexes = I(list(original_row_lst))
)
)
if (type == "conditional_prob") {
if (length(columns) != 2) {
stop("For 'conditional_prob', columns must be a list of length 2: list(A, B)")
}
colA <- columns[[1]]
colB <- columns[[2]]
if (!(colA %in% names(original_data)) || !(colB %in% names(original_data))) {
stop("Specified columns not found in original_data.")
}
sub <- original_data[indexes, c(colA, colB), drop = FALSE]
A <- sub[[colA]]
B <- sub[[colB]]
if (is.logical(A) || is.character(A)) A <- factor(A)
if (is.logical(B) || is.character(B)) B <- factor(B)
if (!is.factor(A) || !is.factor(B)) {
stop("For 'conditional_prob', A and B must be categorical (factor/character/logical).")
}
A <- droplevels(A)
B <- droplevels(B)
# default levels: if not specified, take the first level of each factor
a_lv <- if (is.null(a_level)) levels(A)[1] else a_level
b_lv <- if (is.null(b_level)) levels(B)[1] else b_level
# Formula: P(B=b_lv | A=a_lv) = count(A=a_lv & B=b_lv) / count(A=a_lv)
denom <- sum(A == a_lv, na.rm = TRUE)
if (denom == 0) {
col_data <- NA_real_
} else {
num <- sum(A == a_lv & B == b_lv, na.rm = TRUE)
col_data <- num / denom
}
} else {
stop("type must be 'conditional_prob' for this function version.")
}
target_lst[[i]] <- col_data
}
return(unlist(target_lst))
}
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, list("PW_group", "Species"), 'Petal.Length', type='conditional_prob', a_level = "wide", b_level = "setosa")
embedded <- ColorEmbedding(Mapper, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
ColorEmbedding <- function(
Mapper, original_data, columns=list(), type="mean", a_level = NULL, b_level = NULL
) {
rows <- length(Mapper$level_of_vertex)
df_for_search <- data.frame()
target_lst <- list()
for (i in 1:rows) {
# Get original index
original_row_lst <- Mapper$points_in_vertex[[i]]
df_for_search <- rbind(
df_for_search,
data.frame(
node = i,
original_indexes = I(list(original_row_lst))
)
)
if (type == "conditional_prob") {
if (length(columns) != 2) {
stop("For 'conditional_prob', columns must be a list of length 2: list(A, B)")
}
colA <- columns[[1]]
colB <- columns[[2]]
if (!(colA %in% names(original_data)) || !(colB %in% names(original_data))) {
stop("Specified columns not found in original_data.")
}
sub <- original_data[indexes, c(colA, colB), drop = FALSE]
A <- sub[[colA]]
B <- sub[[colB]]
if (is.logical(A) || is.character(A)) A <- factor(A)
if (is.logical(B) || is.character(B)) B <- factor(B)
if (!is.factor(A) || !is.factor(B)) {
stop("For 'conditional_prob', A and B must be categorical (factor/character/logical).")
}
A <- droplevels(A)
B <- droplevels(B)
# default levels: if not specified, take the first level of each factor
a_lv <- if (is.null(a_level)) levels(A)[1] else a_level
b_lv <- if (is.null(b_level)) levels(B)[1] else b_level
# Formula: P(B=b_lv | A=a_lv) = count(A=a_lv & B=b_lv) / count(A=a_lv)
denom <- sum(A == a_lv, na.rm = TRUE)
if (denom == 0) {
col_data <- NA_real_
} else {
num <- sum(A == a_lv & B == b_lv, na.rm = TRUE)
col_data <- num / denom
}
} else {
stop("type must be 'conditional_prob' for this function version.")
}
target_lst[[i]] <- col_data
}
return(unlist(target_lst))
}
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
ColorEmbedding <- function(
Mapper, original_data, columns=list(), type="mean", a_level = NULL, b_level = NULL
) {
rows <- length(Mapper$level_of_vertex)
df_for_search <- data.frame()
target_lst <- list()
for (i in 1:rows) {
# Get original index
original_row_lst <- Mapper$points_in_vertex[[i]]
df_for_search <- rbind(
df_for_search,
data.frame(
node = i,
original_indexes = I(list(original_row_lst))
)
)
if (type == "conditional_prob") {
if (length(columns) != 2) {
stop("For 'conditional_prob', columns must be a list of length 2: list(A, B)")
}
colA <- columns[[1]]
colB <- columns[[2]]
print(colA)
print(colB)
if (!(colA %in% names(original_data)) || !(colB %in% names(original_data))) {
stop("Specified columns not found in original_data.")
}
sub <- original_data[indexes, c(colA, colB), drop = FALSE]
A <- sub[[colA]]
B <- sub[[colB]]
if (is.logical(A) || is.character(A)) A <- factor(A)
if (is.logical(B) || is.character(B)) B <- factor(B)
if (!is.factor(A) || !is.factor(B)) {
stop("For 'conditional_prob', A and B must be categorical (factor/character/logical).")
}
A <- droplevels(A)
B <- droplevels(B)
# default levels: if not specified, take the first level of each factor
a_lv <- if (is.null(a_level)) levels(A)[1] else a_level
b_lv <- if (is.null(b_level)) levels(B)[1] else b_level
# Formula: P(B=b_lv | A=a_lv) = count(A=a_lv & B=b_lv) / count(A=a_lv)
denom <- sum(A == a_lv, na.rm = TRUE)
if (denom == 0) {
col_data <- NA_real_
} else {
num <- sum(A == a_lv & B == b_lv, na.rm = TRUE)
col_data <- num / denom
}
} else {
stop("type must be 'conditional_prob' for this function version.")
}
target_lst[[i]] <- col_data
}
return(unlist(target_lst))
}
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
ColorEmbedding <- function(
Mapper, original_data, columns=list(), type="mean", a_level = NULL, b_level = NULL
) {
rows <- length(Mapper$level_of_vertex)
df_for_search <- data.frame()
target_lst <- list()
for (i in 1:rows) {
# Get original index
original_row_lst <- Mapper$points_in_vertex[[i]]
df_for_search <- rbind(
df_for_search,
data.frame(
node = i,
original_indexes = I(list(original_row_lst))
)
)
if (type == "conditional_prob") {
if (length(columns) != 2) {
stop("For 'conditional_prob', columns must be a list of length 2: list(A, B)")
}
colA <- columns[[1]]
colB <- columns[[2]]
if (!(colA %in% names(original_data)) || !(colB %in% names(original_data))) {
stop("Specified columns not found in original_data.")
}
sub <- original_data[indexes, c(colA, colB), drop = FALSE]
A <- sub[[colA]]
B <- sub[[colB]]
if (is.logical(A) || is.character(A)) A <- factor(A)
if (is.logical(B) || is.character(B)) B <- factor(B)
if (!is.factor(A) || !is.factor(B)) {
stop("For 'conditional_prob', A and B must be categorical (factor/character/logical).")
}
A <- droplevels(A)
B <- droplevels(B)
print(A)
peinr(B)
# default levels: if not specified, take the first level of each factor
a_lv <- if (is.null(a_level)) levels(A)[1] else a_level
b_lv <- if (is.null(b_level)) levels(B)[1] else b_level
# Formula: P(B=b_lv | A=a_lv) = count(A=a_lv & B=b_lv) / count(A=a_lv)
denom <- sum(A == a_lv, na.rm = TRUE)
if (denom == 0) {
col_data <- NA_real_
} else {
num <- sum(A == a_lv & B == b_lv, na.rm = TRUE)
col_data <- num / denom
}
} else {
stop("type must be 'conditional_prob' for this function version.")
}
target_lst[[i]] <- col_data
}
return(unlist(target_lst))
}
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
ColorEmbedding <- function(
Mapper, original_data, columns=list(), type="mean", a_level = NULL, b_level = NULL
) {
rows <- length(Mapper$level_of_vertex)
df_for_search <- data.frame()
target_lst <- list()
for (i in 1:rows) {
# Get original index
original_row_lst <- Mapper$points_in_vertex[[i]]
df_for_search <- rbind(
df_for_search,
data.frame(
node = i,
original_indexes = I(list(original_row_lst))
)
)
indexes <- df_for_search[i, ]$original_indexes[[1]]
if (type == "conditional_prob") {
if (length(columns) != 2) {
stop("For 'conditional_prob', columns must be a list of length 2: list(A, B)")
}
colA <- columns[[1]]
colB <- columns[[2]]
if (!(colA %in% names(original_data)) || !(colB %in% names(original_data))) {
stop("Specified columns not found in original_data.")
}
sub <- original_data[indexes, c(colA, colB), drop = FALSE]
A <- sub[[colA]]
B <- sub[[colB]]
if (is.logical(A) || is.character(A)) A <- factor(A)
if (is.logical(B) || is.character(B)) B <- factor(B)
if (!is.factor(A) || !is.factor(B)) {
stop("For 'conditional_prob', A and B must be categorical (factor/character/logical).")
}
A <- droplevels(A)
B <- droplevels(B)
# default levels: if not specified, take the first level of each factor
a_lv <- if (is.null(a_level)) levels(A)[1] else a_level
b_lv <- if (is.null(b_level)) levels(B)[1] else b_level
# Formula: P(B=b_lv | A=a_lv) = count(A=a_lv & B=b_lv) / count(A=a_lv)
denom <- sum(A == a_lv, na.rm = TRUE)
if (denom == 0) {
col_data <- NA_real_
} else {
num <- sum(A == a_lv & B == b_lv, na.rm = TRUE)
col_data <- num / denom
}
} else {
stop("type must be 'conditional_prob' for this function version.")
}
target_lst[[i]] <- col_data
}
return(unlist(target_lst))
}
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
source('R/Plotter.R')
MapperPlotter(Mapper, label=embedded, data=data, type="forceNetwork", avg=TRUE, use_embedding=TRUE)
MapperPlotter(Mapper, label=embedded, data=data, type="forceNetwork", avg=FALSE, use_embedding=TRUE)
embedded
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "setosa")
data
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "virginica")
embedded
ColorEmbedding <- function(
Mapper, original_data, columns=list(), type="mean", a_level = NULL, b_level = NULL
) {
rows <- length(Mapper$level_of_vertex)
df_for_search <- data.frame()
target_lst <- list()
for (i in 1:rows) {
# Get original index
original_row_lst <- Mapper$points_in_vertex[[i]]
df_for_search <- rbind(
df_for_search,
data.frame(
node = i,
original_indexes = I(list(original_row_lst))
)
)
indexes <- df_for_search[i, ]$original_indexes[[1]]
if (type == "conditional_prob") {
if (length(columns) != 2) {
stop("For 'conditional_prob', columns must be a list of length 2: list(A, B)")
}
colA <- columns[[1]]
colB <- columns[[2]]
if (!(colA %in% names(original_data)) || !(colB %in% names(original_data))) {
stop("Specified columns not found in original_data.")
}
sub <- original_data[indexes, c(colA, colB), drop = FALSE]
A <- sub[[colA]]
B <- sub[[colB]]
if (is.logical(A) || is.character(A)) A <- factor(A)
if (is.logical(B) || is.character(B)) B <- factor(B)
if (!is.factor(A) || !is.factor(B)) {
stop("For 'conditional_prob', A and B must be categorical (factor/character/logical).")
}
A <- droplevels(A)
B <- droplevels(B)
# default levels: if not specified, take the first level of each factor
a_lv <- if (is.null(a_level)) levels(A)[1] else a_level
b_lv <- if (is.null(b_level)) levels(B)[1] else b_level
# Formula: P(B=b_lv | A=a_lv) = count(A=a_lv & B=b_lv) / count(A=a_lv)
denom <- sum(A == a_lv, na.rm = TRUE)
if (denom == 0) {
col_data <- NA_real_
} else {
num <- sum(A == a_lv & B == b_lv, na.rm = TRUE)
col_data <- num / denom
}
} else {
stop("type must be 'conditional_prob' for this function version.")
}
target_lst[[i]] <- col_data
print(target_lst)
}
return(unlist(target_lst))
}
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "virginica")
ColorEmbedding <- function(
Mapper, original_data, columns=list(), type="mean", a_level = NULL, b_level = NULL
) {
rows <- length(Mapper$level_of_vertex)
df_for_search <- data.frame()
target_lst <- list()
for (i in 1:rows) {
# Get original index
original_row_lst <- Mapper$points_in_vertex[[i]]
df_for_search <- rbind(
df_for_search,
data.frame(
node = i,
original_indexes = I(list(original_row_lst))
)
)
indexes <- df_for_search[i, ]$original_indexes[[1]]
if (type == "conditional_prob") {
if (length(columns) != 2) {
stop("For 'conditional_prob', columns must be a list of length 2: list(A, B)")
}
colA <- columns[[1]]
colB <- columns[[2]]
if (!(colA %in% names(original_data)) || !(colB %in% names(original_data))) {
stop("Specified columns not found in original_data.")
}
sub <- original_data[indexes, c(colA, colB), drop = FALSE]
A <- sub[[colA]]
B <- sub[[colB]]
if (is.logical(A) || is.character(A)) A <- factor(A)
if (is.logical(B) || is.character(B)) B <- factor(B)
if (!is.factor(A) || !is.factor(B)) {
stop("For 'conditional_prob', A and B must be categorical (factor/character/logical).")
}
A <- droplevels(A)
B <- droplevels(B)
# default levels: if not specified, take the first level of each factor
a_lv <- if (is.null(a_level)) levels(A)[1] else a_level
b_lv <- if (is.null(b_level)) levels(B)[1] else b_level
# Formula: P(B=b_lv | A=a_lv) = count(A=a_lv & B=b_lv) / count(A=a_lv)
denom <- sum(A == a_lv, na.rm = TRUE)
if (denom == 0) {
col_data <- NA_real_
} else {
num <- sum(A == a_lv & B == b_lv, na.rm = TRUE)
col_data <- num / denom
}
} else {
stop("type must be 'conditional_prob' for this function version.")
}
target_lst[[i]] <- col_data
}
ret <- unlist(target_lst)
ret[is.na(ret)] <- 0
return(ret)
}
data$PW_group <- ifelse(data$Petal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "virginica")
embedded
source('R/Plotter.R')
MapperPlotter(Mapper, label=embedded, data=data, type="forceNetwork", avg=FALSE, use_embedding=TRUE)
MapperPlotter(Mapper, label=embedded, data=data, type="forceNetwork", avg=TRUE, use_embedding=TRUE)
MapperPlotter(Mapper, label=embedded, data=data, type="ggraph", avg=TRUE, use_embedding=TRUE)
library(ggraph)
MapperPlotter(Mapper, label=embedded, data=data, type="ggraph", avg=TRUE, use_embedding=TRUE)
library(doParallel)
library(htmlwidgets)
library(webshot)
library(tidygraph)
library(ggraph)
MapperPlotter(Mapper, label=embedded, data=data, type="ggraph", avg=TRUE, use_embedding=TRUE)
MapperPlotter(Mapper, label=embedded, data=data, type="forceNetwork", avg=TRUE, use_embedding=TRUE)
data$Species
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "versicolor")
embedded
data$PW_group <- ifelse(data$Sepal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "versicolor")
embedded
source('R/Plotter.R')
MapperPlotter(Mapper, label=embedded, data=data, type="forceNetwork", avg=TRUE, use_embedding=TRUE)
devtools::document()
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
data("iris")
data <- iris
ggplot(data)+geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species))
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
percent_overlap = 30,
methods = "dbscan",
method_params = list(eps = 1, minPts = 1),
# methods = "hierarchical",
# method_params = list(num_bins_when_clustering = 10, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken
source('R/GridSearch.R')
GridSearch(
filter_values = filter_values,
label = data$Species,
column = 'Species',
cover_type = "stride",
width_vec = c(1.0, 1.5),
overlap_vec = c(10, 20, 30, 40),
num_cores = 12,
out_dir = "../mapper_grid_outputs",
use_embedding = TRUE,
)
source('R/ColorEmbedding.R')
data$PW_group <- ifelse(data$Sepal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "versicolor")
embedded
source('R/ColorEmbedding.R')
source('R/CPEmbedding.R')
data$PW_group <- ifelse(data$Sepal.Width > 1.5, "wide", "narrow")
embedded <- ColorEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "versicolor")
embedded <- CPEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "versicolor")
data$PW_group <- ifelse(data$Sepal.Width > 1.5, "wide", "narrow")
embedded <- CPEmbedding(Mapper, data, columns = list("PW_group", "Species"), type='conditional_prob', a_level = "wide", b_level = "versicolor")
embedded <- CPEmbedding(Mapper, data, columns = list("PW_group", "Species"), a_level = "wide", b_level = "versicolor")
embedded
source('R/Plotter.R')
MapperPlotter(Mapper, label=embedded, data=data, type="forceNetwork", avg=TRUE, use_embedding=TRUE)
devtools::document()
devtools::document()
