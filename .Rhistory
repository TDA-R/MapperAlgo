# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken
library(ggplot2)
library(igraph)
library(networkD3)
library(parallel)
library(foreach)
library(doParallel)
library(htmlwidgets)
library(webshot)
library(tidygraph)
library(ggraph)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('R/Plotter.R')
source('ExampleData.R')
library(ggplot2)
library(tidyverse)
source('R/ConvertLevelsets.R')
make_noisy_circle <- function(radius, num_points, noise_sd = 0.05) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
source('ExampleData.R')
circle_data <- reader(dataset_name = 'circle')
calc_n_stride <- function(L, w, p) {
stride <- w * (1 - p/100)
ifelse(L <= w, 1L, as.integer(ceiling((L - w) / pmax(stride, .Machine$double.eps)) + 1L))
}
calc_n_extension <- function(L, w, p) {
as.integer(pmax(1, ceiling(L / w - p/100)))
}
# same as cover_points but with different return
get_cell_bounds <- function(
lsfi, filter_min, interval_width, percent_overlap,
num_intervals, type=c("stride","extension")
){
type <- match.arg(type)
lsmi <- to_lsmi(lsfi, num_intervals)
if (type == "stride") {
stride <- interval_width * (1 - percent_overlap / 100)
anchor <- filter_min + (lsmi - 1) * stride
lsfmin <- anchor
lsfmax <- anchor + interval_width
} else {
anchor <- filter_min + (lsmi - 1) * interval_width
ext    <- 0.5 * interval_width * percent_overlap / 100
lsfmin <- anchor - ext
lsfmax <- anchor + interval_width + ext
}
list(min=lsfmin, max=lsfmax)
}
plot_cover_with_grid <- function(data, type, num_intervals,
filter_min, interval_width, percent_overlap,
domain_min, domain_max){
total  <- prod(num_intervals)
bounds <- lapply(1:total, function(i){
get_cell_bounds(i, filter_min, interval_width, percent_overlap, num_intervals, type)
})
print(bounds)
xv <- sort(unique(unlist(lapply(bounds, function(b) c(b$min[1], b$max[1])))))
yh <- sort(unique(unlist(lapply(bounds, function(b) c(b$min[2], b$max[2])))))
p <- ggplot(data, aes(x=x, y=y, color=circle)) +
geom_point(alpha=0.4, size=0.7) +
coord_equal(xlim = c(domain_min, domain_max), ylim = c(domain_min, domain_max)) +
theme_minimal() +
labs(
title = sprintf("%s cover (w=%g, overlap=%g%%, n=c(%d,%d))",
type, interval_width[1], percent_overlap[1],
num_intervals[1], num_intervals[2]),
x = "x", y = "y"
) +
theme(legend.position="top")
for (v in xv) p <- p + geom_vline(xintercept=v, color="black", linewidth=0.3)
for (h in yh) p <- p + geom_hline(yintercept=h, color="black", linewidth=0.3)
p
}
max(circle_data$y%>%max(), circle_data$x%>%max())
domain_min <- min(circle_data$y%>%min(), circle_data$x%>%min())
domain_max <- max(circle_data$y%>%max(), circle_data$x%>%max())
r <- ncol(circle_data) - 1 # minus label
interval_width <- rep(1, r)
percent_overlap <- rep(30, r)
filter_min <- rep(domain_min, r)
L <- rep(domain_max - domain_min, r)
num_intervals <- rep(2, r)
num_intervals_stride <- calc_n_stride(L, interval_width, percent_overlap)
num_intervals_ext <- calc_n_extension(L, interval_width, percent_overlap)
p_stride <- plot_cover_with_grid(
circle_data, "stride",
num_intervals_stride,
# num_intervals,
filter_min, interval_width, percent_overlap,
domain_min, domain_max
)
p_ext <- plot_cover_with_grid(
circle_data, "extension",
num_intervals_ext,
# num_intervals,
filter_min, interval_width, percent_overlap,
domain_min, domain_max
)
mrf <- gridExtra::grid.arrange(p_stride, p_ext, ncol = 2)
# compute coverage for sample points
sample_pts <- rbind(
data.frame(label="A", x= 0,   y= 0),
data.frame(label="B", x= 1.0, y= 1.0),
data.frame(label="C", x= 2.0, y= 0.0),
data.frame(label="D", x= 0.0, y= 2.0),
data.frame(label="E", x= 1.99, y= 2.01),
data.frame(label="F", x=-1.5, y= 1.5)
)
count_cells <- function(type){
total <- prod(num_intervals)
apply(sample_pts[,c("x","y")], 1, function(pt){
sum(sapply(1:total, function(i){
idx <- cover_points(i, filter_min, interval_width, percent_overlap,
rbind(pt), num_intervals, type=type)
length(idx) > 0
}))
})
}
source('R/Cover.R')
sample_pts$stride_cells <- count_cells("stride")
sample_pts$ext_cells <- count_cells("extension")
sample_pts
mrf <- gridExtra::grid.arrange(p_stride, p_ext, ncol = 2)
# compute coverage for sample points
sample_pts <- rbind(
data.frame(label="A", x= 0,   y= 0),
data.frame(label="B", x= 1.0, y= 1.0),
data.frame(label="C", x= 2.0, y= 0.0),
data.frame(label="D", x= 0.0, y= 2.0),
data.frame(label="E", x= 1.99, y= 2.01),
data.frame(label="F", x=-1.5, y= 1.5)
)
count_cells <- function(type){
total <- prod(num_intervals)
apply(sample_pts[,c("x","y")], 1, function(pt){
sum(sapply(1:total, function(i){
idx <- cover_points(i, filter_min, interval_width, percent_overlap,
rbind(pt), num_intervals, type=type)
length(idx) > 0
}))
})
}
source('R/Cover.R')
sample_pts$stride_cells <- count_cells("stride")
sample_pts$ext_cells <- count_cells("extension")
sample_pts
num_intervals_stride <- calc_n_stride(L, interval_width, percent_overlap)
num_intervals_ext <- calc_n_extension(L, interval_width, percent_overlap)
p_stride <- plot_cover_with_grid(
circle_data, "stride",
num_intervals_stride,
# num_intervals,
filter_min, interval_width, percent_overlap,
domain_min, domain_max
)
p_stride <- plot_cover_with_grid(
circle_data, "stride",
num_intervals_stride,
# num_intervals,
filter_min, interval_width, percent_overlap,
domain_min, domain_max
)
p_ext <- plot_cover_with_grid(
circle_data, "extension",
num_intervals_ext,
# num_intervals,
filter_min, interval_width, percent_overlap,
domain_min, domain_max
)
source('R/Prescan.R')
source('R/MapperAlgo.R')
data("iris")
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
# filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
data("iris")
data <- iris
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
# filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
mnist <- reader(dataset_name = 'mnist')
ggplot(mnist)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
length(m$points_in_level_set)
length(Mapper$points_in_level_set)
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
source('R/MapperAlgo.R')
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
# methods = "hierarchical",
# method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
methods = "kmeans",
method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
## Save mapper
library(jsonlite)
export_data <- list(
adjacency = mapperoutput$adjacency,
num_vertices = mapperoutput$num_vertices,
level_of_vertex = mapperoutput$level_of_vertex,
points_in_vertex = mapperoutput$points_in_vertex,
original_data = as.data.frame(all_features)
)
mnist
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = mnist
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/mnist.json")
Mapper$points_in_vertex
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = as.matrix(mnist)
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/mnist.json")
mnist
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = as.matrix(mnist$label)
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/mnist.json")
library(ggplot2)
library(igraph)
library(networkD3)
library(parallel)
library(foreach)
library(doParallel)
library(htmlwidgets)
library(webshot)
library(tidygraph)
library(ggraph)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('R/Plotter.R')
source('ExampleData.R')
source('R/Prescan.R')
source('R/Prescan.R')
source('ExampleData.R')
data("iris")
data <- iris
circle_data <- reader(dataset_name = 'circle')
mnist <- reader(dataset_name = 'mnist')
ggplot(mnist)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
circle_data <- reader(dataset_name = 'circle')
mnist <- reader(dataset_name = 'mnist')
reader <- function(dataset_name='iris') {
if(dataset_name == 'mnist') {
# mnist
# Sys.setenv(RETICULATE_PYTHON = "/Users/wangqiqian/.virtualenvs/r-tensorflow/bin/python")
library(reticulate)
py_config()
library(keras)
mnist <- dataset_mnist()
train_image <- mnist$train$x
train_label <- mnist$train$y
train_flat <- array_reshape(train_image, c(nrow(train_image), 784))
train_df <- data.frame(train_flat) %>% select_if(~ sd(.) > 0)
pca_result <- prcomp(train_df, center = TRUE, scale. = TRUE)
data <- data.frame(pca_result$x)
data$label <- train_label
} else if (dataset_name == 'circle') {
# circle
make_noisy_circle <- function(radius, num_points, noise_sd = 0.1) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
noisy_inner_circle <- make_noisy_circle(radius = 1, num_points = 1000)
noisy_outer_circle <- make_noisy_circle(radius = 2, num_points = 1000)
data <- rbind(
data.frame(circle = "inner", noisy_inner_circle),
data.frame(circle = "outer",noisy_outer_circle)
)
}
return(data)
}
source('ExampleData.R')
circle_data <- reader(dataset_name = 'circle')
mnist <- reader(dataset_name = 'mnist')
library(tidygraph)
source('ExampleData.R')
mnist <- reader(dataset_name = 'mnist')
ggplot(mnist)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
# methods = "hierarchical",
# method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
methods = "kmeans",
method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
Mapper
View(Mapper)
Mapper$adjacency
dim(Mapper$adjacency)
Mapper$num_vertices
Mapper$level_of_vertex
dim(Mapper$adjacency)
Mapper$adjacency
Mapper$points_in_vertex
dim(Mapper$adjacency)
Mapper$adjacency
Mapper$num_vertices
Mapper$points_in_vertex
size <- c()
for (i in 1:Mapper$num_vertices) {
size[i] <- length(Mapper$points_in_vertex[[i]])
}
size
Mapper$points_in_vertex
Mapper$adjacency
Mapper$num_vertices
Mapper$points_in_vertex
adj_indices <- which(Mapper$adjacency == 1, arr.ind = TRUE)
adj_indices
adj_indices <- which(Mapper$adjacency == 1, arr.ind = TRUE)
adj_indices <- adj_indices[adj_indices[, 1] < adj_indices[, 2], , drop = FALSE]
# 計算每個連線的共同資料點數量
edge_weights <- apply(adj_indices, 1, function(idx) {
length(intersect(piv[[idx[1]]], piv[[idx[2]]]))
})
adj_indices <- which(Mapper$adjacency == 1, arr.ind = TRUE)
adj_indices <- adj_indices[adj_indices[, 1] < adj_indices[, 2], , drop = FALSE]
adj_indices
edge_weights <- apply(adj_indices, 1, function(idx) {
length(intersect(piv[[idx[1]]], piv[[idx[2]]]))
})
piv <- Mapper$points_in_vertex
edge_weights <- apply(adj_indices, 1, function(idx) {
length(intersect(piv[[idx[1]]], piv[[idx[2]]]))
})
edge_weights
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="ggraph", avg=FALSE, use_embedding=FALSE)
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="ggraph", avg=FALSE, use_embedding=FALSE)
