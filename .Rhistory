# Majority vote for each vertex
var.maj.vertex <- c()
circle_groups <- as.character(circle_data$circle)
for (i in 1:l) {
points.in.vertex <- Mapper$points_in_vertex[[i]]
Mode.in.vertex <- Mode(circle_groups[points.in.vertex])
var.maj.vertex <- c(var.maj.vertex, as.character(Mode.in.vertex))
}
# Node data
vertex.size <- sapply(1:l, function(i) length(Mapper$points_in_vertex[[i]]))
MapperNodes <- mapperVertices(Mapper, 1:nrow(circle_data))
MapperNodes$Group <- as.factor(var.maj.vertex)
MapperNodes$Nodesize <- vertex.size
# Edge data
MapperLinks <- mapperEdges(Mapper)
# Generate Force Network
forceNetwork(
Nodes = MapperNodes,
Links = MapperLinks,
Source = "Linksource",
Target = "Linktarget",
Value = "Linkvalue",
NodeID = "Nodename",
Nodesize = "Nodesize",
Group = "Group",
opacity = 1,
zoom = TRUE,
radiusCalculation = JS("Math.sqrt(d.nodesize)"),
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),
linkDistance = 30,
charge = -10,
legend = TRUE
)
})
}
shinyApp(ui, server)
library(shiny)
library(networkD3)
library(igraph)
library(ggplot2)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
make_noisy_circle <- function(radius, num_points, noise_sd = 0.05) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
noisy_inner_circle <- make_noisy_circle(radius = 1, num_points = 1000)
noisy_outer_circle <- make_noisy_circle(radius = 2, num_points = 1000)
circle_data <- rbind(
data.frame(circle = "inner", noisy_inner_circle),
data.frame(circle = "outer",noisy_outer_circle)
)
# Shiny App
server <- function(input, output, session) {
# Plot for circle_data
output$circlePlot <- renderPlot({
ggplot(circle_data) +
geom_point(aes(x = x, y = y, color = circle)) +
theme_minimal() +
labs(title = "Circle Data", x = "X", y = "Y", color = "Group")
})
# Mapper Algorithm and Force Network
output$mapperPlot <- renderForceNetwork({
clustering_method <- input$clustering_method
# 根據選擇的方法設置對應的參數
method_params <- switch(
clustering_method,
"dbscan" = list(eps = input$eps, minPts = input$minPts),
"kmeans" = list(centers = as.integer(input$minPts)), # 使用 minPts 作為群組數
"hierarchical" = list(method = "ward.D2"), # 可選 "complete", "average", "single"
"pam" = list(k = as.integer(input$minPts)), # 使用 minPts 作為群組數
stop("Unknown clustering method")
)
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = circle_data[, 2:3],
intervals = input$intervals,
percent_overlap = input$overlap,
num_bins_when_clustering = 10,
methods = clustering_method,
method_params = method_params
)
})
Graph <- graph.adjacency(Mapper$adjacency, mode = "undirected")
l <- length(V(Graph))
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
# Majority vote for each vertex
var.maj.vertex <- c()
circle_groups <- as.character(circle_data$circle)
for (i in 1:l) {
points.in.vertex <- Mapper$points_in_vertex[[i]]
Mode.in.vertex <- Mode(circle_groups[points.in.vertex])
var.maj.vertex <- c(var.maj.vertex, as.character(Mode.in.vertex))
}
# Node data
vertex.size <- sapply(1:l, function(i) length(Mapper$points_in_vertex[[i]]))
MapperNodes <- mapperVertices(Mapper, 1:nrow(circle_data))
MapperNodes$Group <- as.factor(var.maj.vertex)
MapperNodes$Nodesize <- vertex.size
# Edge data
MapperLinks <- mapperEdges(Mapper)
# Generate Force Network
forceNetwork(
Nodes = MapperNodes,
Links = MapperLinks,
Source = "Linksource",
Target = "Linktarget",
Value = "Linkvalue",
NodeID = "Nodename",
Nodesize = "Nodesize",
Group = "Group",
opacity = 1,
zoom = TRUE,
radiusCalculation = JS("Math.sqrt(d.nodesize)"),
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),
linkDistance = 30,
charge = -10,
legend = TRUE
)
})
}
shinyApp(ui, server)
ui <- fluidPage(
titlePanel("Mapper Visualization with Shiny"),
sidebarLayout(
sidebarPanel(
sliderInput("intervals", "Number of intervals:", min = 2, max = 10, value = 4),
sliderInput("overlap", "Percent overlap:", min = 10, max = 90, value = 50, step = 5),
numericInput("eps", "DBSCAN eps:", value = 0.5, step = 0.1),
numericInput("minPts", "DBSCAN minPts:", value = 5),
selectInput(
"clustering_method",
"Clustering Method:",
choices = c("hierarchical", "kmeans", "dbscan", "pam"),
selected = "dbscan"
)
),
mainPanel(
fluidRow(
column(6, plotOutput("circlePlot")),
column(6, forceNetworkOutput("mapperPlot"))
)
)
)
)
server <- function(input, output, session) {
# Plot for circle_data
output$circlePlot <- renderPlot({
ggplot(circle_data) +
geom_point(aes(x = x, y = y, color = circle)) +
theme_minimal() +
labs(title = "Circle Data", x = "X", y = "Y", color = "Group")
})
# Mapper Algorithm and Force Network
output$mapperPlot <- renderForceNetwork({
clustering_method <- input$clustering_method
# 根據選擇的方法設置對應的參數
method_params <- switch(
clustering_method,
"dbscan" = list(eps = input$eps, minPts = input$minPts),
"kmeans" = list(centers = as.integer(input$minPts)), # 使用 minPts 作為群組數
"hierarchical" = list(method = "ward.D2"), # 可選 "complete", "average", "single"
"pam" = list(k = as.integer(input$minPts)), # 使用 minPts 作為群組數
stop("Unknown clustering method")
)
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = circle_data[, 2:3],
intervals = input$intervals,
percent_overlap = input$overlap,
num_bins_when_clustering = 10,
methods = clustering_method,
method_params = method_params
)
})
Graph <- graph.adjacency(Mapper$adjacency, mode = "undirected")
l <- length(V(Graph))
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
# Majority vote for each vertex
var.maj.vertex <- c()
circle_groups <- as.character(circle_data$circle)
for (i in 1:l) {
points.in.vertex <- Mapper$points_in_vertex[[i]]
Mode.in.vertex <- Mode(circle_groups[points.in.vertex])
var.maj.vertex <- c(var.maj.vertex, as.character(Mode.in.vertex))
}
# Node data
vertex.size <- sapply(1:l, function(i) length(Mapper$points_in_vertex[[i]]))
MapperNodes <- mapperVertices(Mapper, 1:nrow(circle_data))
MapperNodes$Group <- as.factor(var.maj.vertex)
MapperNodes$Nodesize <- vertex.size
# Edge data
MapperLinks <- mapperEdges(Mapper)
# Generate Force Network
forceNetwork(
Nodes = MapperNodes,
Links = MapperLinks,
Source = "Linksource",
Target = "Linktarget",
Value = "Linkvalue",
NodeID = "Nodename",
Nodesize = "Nodesize",
Group = "Group",
opacity = 1,
zoom = TRUE,
radiusCalculation = JS("Math.sqrt(d.nodesize)"),
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),
linkDistance = 30,
charge = -10,
legend = TRUE
)
})
}
shinyApp(ui, server)
# Toy dataset testing
make_noisy_circle <- function(radius, num_points, noise_sd = 0.05) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
noisy_inner_circle <- make_noisy_circle(radius = 1, num_points = 1000)
noisy_outer_circle <- make_noisy_circle(radius = 2, num_points = 1000)
circle_data <- rbind(
data.frame(circle = "inner", noisy_inner_circle),
data.frame(circle = "outer",noisy_outer_circle)
)
ggplot(circle_data)+geom_point(aes(x = x, y = y, color = circle))
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = iris[,1:4],
filter_values = circle_data[,2:3],
intervals = 4,
percent_overlap = 50,
methods = "dbscan",
method_params = list(eps = 0.5, minPts = 5)
)
})
time_taken
server <- function(input, output, session) {
# Plot for circle_data
output$circlePlot <- renderPlot({
ggplot(circle_data) +
geom_point(aes(x = x, y = y, color = circle)) +
theme_minimal() +
labs(title = "Circle Data", x = "X", y = "Y", color = "Group")
})
# Mapper Algorithm and Force Network
output$mapperPlot <- renderForceNetwork({
clustering_method <- input$clustering_method
# 根據選擇的方法設置對應的參數
method_params <- switch(
clustering_method,
"dbscan" = list(eps = input$eps, minPts = input$minPts),
"kmeans" = list(centers = as.integer(input$minPts)), # 使用 minPts 作為群組數
"hierarchical" = list(method = "ward.D2"), # 可選 "complete", "average", "single"
"pam" = list(k = as.integer(input$minPts)), # 使用 minPts 作為群組數
stop("Unknown clustering method")
)
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = circle_data[, 2:3],
intervals = input$intervals,
percent_overlap = input$overlap,
num_bins_when_clustering = 10,
methods = clustering_method,
method_params = method_params
)
})
Graph <- graph.adjacency(Mapper$adjacency, mode = "undirected")
l <- length(V(Graph))
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
# Majority vote for each vertex
var.maj.vertex <- c()
circle_groups <- as.character(circle_data$circle)
for (i in 1:l) {
points.in.vertex <- Mapper$points_in_vertex[[i]]
Mode.in.vertex <- Mode(circle_groups[points.in.vertex])
var.maj.vertex <- c(var.maj.vertex, as.character(Mode.in.vertex))
}
# Node data
vertex.size <- sapply(1:l, function(i) length(Mapper$points_in_vertex[[i]]))
MapperNodes <- mapperVertices(Mapper, 1:nrow(circle_data))
MapperNodes$Group <- as.factor(var.maj.vertex)
MapperNodes$Nodesize <- vertex.size
# Edge data
MapperLinks <- mapperEdges(Mapper)
# Generate Force Network
forceNetwork(
Nodes = MapperNodes,
Links = MapperLinks,
Source = "Linksource",
Target = "Linktarget",
Value = "Linkvalue",
NodeID = "Nodename",
Nodesize = "Nodesize",
Group = "Group",
opacity = 1,
zoom = TRUE,
radiusCalculation = JS("Math.sqrt(d.nodesize)"),
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),
linkDistance = 30,
charge = -10,
legend = TRUE
)
})
}
shinyApp(ui, server)
server <- function(input, output, session) {
# Plot for circle_data
output$circlePlot <- renderPlot({
ggplot(circle_data) +
geom_point(aes(x = x, y = y, color = circle)) +
theme_minimal() +
labs(title = "Circle Data", x = "X", y = "Y", color = "Group")
})
# Mapper Algorithm and Force Network
output$mapperPlot <- renderForceNetwork({
clustering_method <- input$clustering_method
# 根據選擇的方法設置對應的參數
method_params <- switch(
clustering_method,
"dbscan" = list(eps = input$eps, minPts = input$minPts),
"kmeans" = list(centers = as.integer(input$minPts)), # 使用 minPts 作為群組數
"hierarchical" = list(method = "ward.D2"), # 可選 "complete", "average", "single"
"pam" = list(k = as.integer(input$minPts)), # 使用 minPts 作為群組數
stop("Unknown clustering method")
)
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = circle_data[, 2:3],
intervals = input$intervals,
percent_overlap = input$overlap,
num_bins_when_clustering = 10,
methods = clustering_method,
method_params = method_params
)
})
Graph <- graph.adjacency(Mapper$adjacency, mode = "undirected")
l <- length(V(Graph))
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
# Majority vote for each vertex
var.maj.vertex <- c()
circle_groups <- as.character(circle_data$circle)
for (i in 1:l) {
points.in.vertex <- Mapper$points_in_vertex[[i]]
Mode.in.vertex <- Mode(circle_groups[points.in.vertex])
var.maj.vertex <- c(var.maj.vertex, as.character(Mode.in.vertex))
}
# Node data
vertex.size <- sapply(1:l, function(i) length(Mapper$points_in_vertex[[i]]))
MapperNodes <- mapperVertices(Mapper, 1:nrow(circle_data))
MapperNodes$Group <- as.factor(var.maj.vertex)
MapperNodes$Nodesize <- vertex.size
# Edge data
MapperLinks <- mapperEdges(Mapper)
# Generate Force Network
forceNetwork(
Nodes = MapperNodes,
Links = MapperLinks,
Source = "Linksource",
Target = "Linktarget",
Value = "Linkvalue",
NodeID = "Nodename",
Nodesize = "Nodesize",
Group = "Group",
opacity = 1,
zoom = TRUE,
radiusCalculation = JS("Math.sqrt(d.nodesize)"),
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),
linkDistance = 30,
charge = -10,
legend = TRUE
)
})
}
shinyApp(ui, server)
shinyApp(ui, server)
shinyApp(ui, server)
library(shiny)
library(networkD3)
library(igraph)
library(ggplot2)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
make_noisy_circle <- function(radius, num_points, noise_sd = 0.05) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
noisy_inner_circle <- make_noisy_circle(radius = 1, num_points = 1000)
noisy_outer_circle <- make_noisy_circle(radius = 2, num_points = 1000)
circle_data <- rbind(
data.frame(circle = "inner", noisy_inner_circle),
data.frame(circle = "outer",noisy_outer_circle)
)
ui <- fluidPage(
titlePanel("Mapper Visualization with Shiny"),
sidebarLayout(
sidebarPanel(
sliderInput("intervals", "Number of intervals:", min = 2, max = 10, value = 4),
sliderInput("overlap", "Percent overlap:", min = 10, max = 90, value = 50, step = 5),
numericInput("eps", "DBSCAN eps:", value = 0.5, step = 0.1),
numericInput("minPts", "DBSCAN minPts:", value = 5),
selectInput(
"clustering_method",
"Clustering Method:",
choices = c("hierarchical", "kmeans", "dbscan", "pam"),
selected = "dbscan"
)
),
mainPanel(
fluidRow(
column(6, plotOutput("circlePlot")),
column(6, forceNetworkOutput("mapperPlot"))
)
)
)
)
server <- function(input, output, session) {
# Plot for circle_data
output$circlePlot <- renderPlot({
ggplot(circle_data) +
geom_point(aes(x = x, y = y, color = circle)) +
theme_minimal() +
labs(title = "Circle Data", x = "X", y = "Y", color = "Group")
})
# Mapper Algorithm and Force Network
output$mapperPlot <- renderForceNetwork({
clustering_method <- input$clustering_method
# 根據選擇的方法設置對應的參數
method_params <- switch(
clustering_method,
"dbscan" = list(eps = input$eps, minPts = input$minPts),
"kmeans" = list(centers = as.integer(input$minPts)), # 使用 minPts 作為群組數
"hierarchical" = list(method = "ward.D2"), # 可選 "complete", "average", "single"
"pam" = list(k = as.integer(input$minPts)), # 使用 minPts 作為群組數
stop("Unknown clustering method")
)
time_taken <- system.time({
Mapper <- MapperAlgo(
filter_values = circle_data[, 2:3],
intervals = input$intervals,
percent_overlap = input$overlap,
methods = clustering_method,
method_params = method_params
)
})
Graph <- graph.adjacency(Mapper$adjacency, mode = "undirected")
l <- length(V(Graph))
Mode <- function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
# Majority vote for each vertex
var.maj.vertex <- c()
circle_groups <- as.character(circle_data$circle)
for (i in 1:l) {
points.in.vertex <- Mapper$points_in_vertex[[i]]
Mode.in.vertex <- Mode(circle_groups[points.in.vertex])
var.maj.vertex <- c(var.maj.vertex, as.character(Mode.in.vertex))
}
# Node data
vertex.size <- sapply(1:l, function(i) length(Mapper$points_in_vertex[[i]]))
MapperNodes <- mapperVertices(Mapper, 1:nrow(circle_data))
MapperNodes$Group <- as.factor(var.maj.vertex)
MapperNodes$Nodesize <- vertex.size
# Edge data
MapperLinks <- mapperEdges(Mapper)
# Generate Force Network
forceNetwork(
Nodes = MapperNodes,
Links = MapperLinks,
Source = "Linksource",
Target = "Linktarget",
Value = "Linkvalue",
NodeID = "Nodename",
Nodesize = "Nodesize",
Group = "Group",
opacity = 1,
zoom = TRUE,
radiusCalculation = JS("Math.sqrt(d.nodesize)"),
colourScale = JS("d3.scaleOrdinal(d3.schemeCategory10);"),
linkDistance = 30,
charge = -10,
legend = TRUE
)
})
}
