# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
mnist <- reader(dataset_name = 'mnist')
ggplot(mnist)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
length(m$points_in_level_set)
length(Mapper$points_in_level_set)
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
source('R/MapperAlgo.R')
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
methods = "hierarchical",
method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
# methods = "kmeans",
# method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
# methods = "hierarchical",
# method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
methods = "kmeans",
method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
## Save mapper
library(jsonlite)
export_data <- list(
adjacency = mapperoutput$adjacency,
num_vertices = mapperoutput$num_vertices,
level_of_vertex = mapperoutput$level_of_vertex,
points_in_vertex = mapperoutput$points_in_vertex,
original_data = as.data.frame(all_features)
)
mnist
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = mnist
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/mnist.json")
Mapper$points_in_vertex
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = as.matrix(mnist)
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/mnist.json")
mnist
export_data <- list(
adjacency = Mapper$adjacency,
num_vertices = Mapper$num_vertices,
level_of_vertex = Mapper$level_of_vertex,
points_in_vertex = Mapper$points_in_vertex,
original_data = as.matrix(mnist$label)
)
write(toJSON(export_data, auto_unbox = TRUE), "~/desktop/mnist.json")
library(ggplot2)
library(igraph)
library(networkD3)
library(parallel)
library(foreach)
library(doParallel)
library(htmlwidgets)
library(webshot)
library(tidygraph)
library(ggraph)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('R/Plotter.R')
source('ExampleData.R')
source('R/Prescan.R')
source('R/Prescan.R')
source('ExampleData.R')
data("iris")
data <- iris
circle_data <- reader(dataset_name = 'circle')
mnist <- reader(dataset_name = 'mnist')
ggplot(mnist)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
circle_data <- reader(dataset_name = 'circle')
mnist <- reader(dataset_name = 'mnist')
reader <- function(dataset_name='iris') {
if(dataset_name == 'mnist') {
# mnist
# Sys.setenv(RETICULATE_PYTHON = "/Users/wangqiqian/.virtualenvs/r-tensorflow/bin/python")
library(reticulate)
py_config()
library(keras)
mnist <- dataset_mnist()
train_image <- mnist$train$x
train_label <- mnist$train$y
train_flat <- array_reshape(train_image, c(nrow(train_image), 784))
train_df <- data.frame(train_flat) %>% select_if(~ sd(.) > 0)
pca_result <- prcomp(train_df, center = TRUE, scale. = TRUE)
data <- data.frame(pca_result$x)
data$label <- train_label
} else if (dataset_name == 'circle') {
# circle
make_noisy_circle <- function(radius, num_points, noise_sd = 0.1) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
noisy_inner_circle <- make_noisy_circle(radius = 1, num_points = 1000)
noisy_outer_circle <- make_noisy_circle(radius = 2, num_points = 1000)
data <- rbind(
data.frame(circle = "inner", noisy_inner_circle),
data.frame(circle = "outer",noisy_outer_circle)
)
}
return(data)
}
source('ExampleData.R')
circle_data <- reader(dataset_name = 'circle')
mnist <- reader(dataset_name = 'mnist')
library(tidygraph)
source('ExampleData.R')
mnist <- reader(dataset_name = 'mnist')
ggplot(mnist)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
# filter_values = circle_data[,2:3],
filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
# methods = "hierarchical",
# method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
methods = "kmeans",
method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
Mapper
View(Mapper)
Mapper$adjacency
dim(Mapper$adjacency)
Mapper$num_vertices
Mapper$level_of_vertex
dim(Mapper$adjacency)
Mapper$adjacency
Mapper$points_in_vertex
dim(Mapper$adjacency)
Mapper$adjacency
Mapper$num_vertices
Mapper$points_in_vertex
size <- c()
for (i in 1:Mapper$num_vertices) {
size[i] <- length(Mapper$points_in_vertex[[i]])
}
size
Mapper$points_in_vertex
Mapper$adjacency
Mapper$num_vertices
Mapper$points_in_vertex
adj_indices <- which(Mapper$adjacency == 1, arr.ind = TRUE)
adj_indices
adj_indices <- which(Mapper$adjacency == 1, arr.ind = TRUE)
adj_indices <- adj_indices[adj_indices[, 1] < adj_indices[, 2], , drop = FALSE]
# 計算每個連線的共同資料點數量
edge_weights <- apply(adj_indices, 1, function(idx) {
length(intersect(piv[[idx[1]]], piv[[idx[2]]]))
})
adj_indices <- which(Mapper$adjacency == 1, arr.ind = TRUE)
adj_indices <- adj_indices[adj_indices[, 1] < adj_indices[, 2], , drop = FALSE]
adj_indices
edge_weights <- apply(adj_indices, 1, function(idx) {
length(intersect(piv[[idx[1]]], piv[[idx[2]]]))
})
piv <- Mapper$points_in_vertex
edge_weights <- apply(adj_indices, 1, function(idx) {
length(intersect(piv[[idx[1]]], piv[[idx[2]]]))
})
edge_weights
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="ggraph", avg=FALSE, use_embedding=FALSE)
source('R/Plotter.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="ggraph", avg=FALSE, use_embedding=FALSE)
library(ggplot2)
library(igraph)
library(networkD3)
library(parallel)
library(foreach)
library(doParallel)
library(htmlwidgets)
library(webshot)
library(tidygraph)
library(ggraph)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('ExampleData.R')
source('R/ExampleData.R')
source('inst/example/ExampleData.R')
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('R/Plotter.R')
pca_result <- reader(dataset_name = 'mnist')
library(networkD3)
library(igraph)
library(ggplot2)
library(dplyr)
library(parallel)
library(foreach)
library(doParallel)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('inst/example/ExampleData.R')
pca_result <- reader(dataset_name = 'mnist')
source('inst/example/ExampleData.R')
pca_result <- reader(dataset_name = 'mnist')
library(networkD3)
library(igraph)
library(ggplot2)
library(dplyr)
library(parallel)
library(foreach)
library(doParallel)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('inst/example/ExampleData.R')
pca_result <- reader(dataset_name = 'mnist')
source('inst/example/ExampleData.R')
source('inst/example/ExampleData.R')
install_keras(method = "auto")
library(keras)
reticulate::install_miniconda()
keras::install_keras(method = "conda", envname = "r-reticulate", tensorflow = "cpu")
library(tidyverse)
library(reticulate)
library(keras)
reader <- function(dataset_name='iris') {
if(dataset_name == 'mnist') {
data <- NULL
mnist <- dataset_mnist()
train_image <- mnist$train$x
train_label <- mnist$train$y
train_flat <- array_reshape(train_image, c(nrow(train_image), 784))
train_df <- data.frame(train_flat) %>% select_if(~ sd(.) > 0)
pca_result <- prcomp(train_df, center = TRUE, scale. = TRUE)
data <- data.frame(pca_result$x)
data$label <- train_label
} else if (dataset_name == 'circle') {
# circle
make_noisy_circle <- function(radius, num_points, noise_sd = 0.1) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
noisy_inner_circle <- make_noisy_circle(radius = 1, num_points = 1000)
noisy_outer_circle <- make_noisy_circle(radius = 2, num_points = 1000)
data <- rbind(
data.frame(circle = "inner", noisy_inner_circle),
data.frame(circle = "outer",noisy_outer_circle)
)
}
return(data)
}
pca_result <- reader(dataset_name = 'mnist')
reticulate::conda_list()
library(networkD3)
library(igraph)
library(ggplot2)
library(dplyr)
library(parallel)
library(foreach)
library(doParallel)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('inst/example/ExampleData.R')
pca_result <- reader(dataset_name = 'mnist')
library(keras)
reader <- function(dataset_name='iris') {
if(dataset_name == 'mnist') {
data <- NULL
mnist <- dataset_mnist()
train_image <- mnist$train$x
train_label <- mnist$train$y
train_flat <- array_reshape(train_image, c(nrow(train_image), 784))
train_df <- data.frame(train_flat) %>% select_if(~ sd(.) > 0)
pca_result <- prcomp(train_df, center = TRUE, scale. = TRUE)
data <- data.frame(pca_result$x)
data$label <- train_label
} else if (dataset_name == 'circle') {
# circle
make_noisy_circle <- function(radius, num_points, noise_sd = 0.1) {
theta <- runif(num_points, 0, 2 * pi)
x <- radius * cos(theta) + rnorm(num_points, sd = noise_sd)
y <- radius * sin(theta) + rnorm(num_points, sd = noise_sd)
data.frame(x = x, y = y)
}
noisy_inner_circle <- make_noisy_circle(radius = 1, num_points = 1000)
noisy_outer_circle <- make_noisy_circle(radius = 2, num_points = 1000)
data <- rbind(
data.frame(circle = "inner", noisy_inner_circle),
data.frame(circle = "outer",noisy_outer_circle)
)
}
return(data)
}
pca_result <- reader(dataset_name = 'mnist')
circle_data <- reader(dataset_name = 'circle')
calc_n_stride <- function(L, w, p) {
stride <- w * (1 - p/100)
ifelse(L <= w, 1L, as.integer(ceiling((L - w) / pmax(stride, .Machine$double.eps)) + 1L))
}
calc_n_extension <- function(L, w, p) {
as.integer(pmax(1, ceiling(L / w - p/100)))
}
library(tidyverse)
library(reticulate)
library(keras)
circle_data <- reader(dataset_name = 'circle')
ggplot(mnist)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
ggplot(circle_data)+geom_point(aes(x=mnist[,1], y=mnist[,2], color=as.factor(mnist$label)))+theme_minimal()
time_taken <- system.time({
Mapper <- MapperAlgo(
# filter_values = data[,1:4],
filter_values = circle_data[,2:3],
# filter_values = mnist[,1:2],
percent_overlap = 30,
# methods = "dbscan",
# method_params = list(eps = 1, minPts = 1),
# methods = "hierarchical",
# method_params = list(num_bins_when_clustering = 2, method = 'ward.D2'),
methods = "kmeans",
method_params = list(max_kmeans_clusters = 2),
# methods = "pam",
# method_params = list(num_clusters = 2),
cover_type = 'stride',
# intervals = 4,
interval_width = 1,
num_cores = 12
)
})
time_taken
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
source('R/EdgeVertices.R')
source('R/ConvertLevelsets.R')
source('R/Cover.R')
source('R/Cluster.R')
source('R/SimplicialComplex.R')
source('R/MapperAlgo.R')
source('R/Plotter.R')
source('ExampleData.R')
source('inst/example/ExampleData.R')
MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
# MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
MapperPlotter(Mapper, label=circle_data$circle, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
# MapperPlotter(Mapper, label=mnist$label, data=mnist, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
MapperPlotter(Mapper, label=circle_data$circle, data=circle_data, type="forceNetwork", avg=FALSE, use_embedding=FALSE)
GridSearch(
filter_values = data[,1:4],
label = labels,
column = "Species",
cover_type = "stride",
width_vec = c(1),
overlap_vec = c(30),
num_cores = 12,
out_dir = "../mapper_grid_outputs",
avg = TRUE,
use_embedding = cpe_params
)
length(Mapper$points_in_level_set)
unique_indexes <- unique(unlist(Mapper$points_in_vertex))
unique_indexes%>%length()
unique_levelset <- unique(unlist(Mapper$points_in_level_set))
unique_levelset%>%length()
setdiff(1:150, unique_levelset)
data[,1:4]%>%nrow()
source('R/GridSearch.R')
setdiff(1:150, unique_levelset)
data[,1:4]%>%nrow()
source('R/MapperCorrelation.R')
MapperCorrelation(Mapper, data = data, labels = list(data$Sepal.Length, data$Sepal.Width))
